## 程序员修炼之道 —— 从小工到专家
绪论。这是一本经验方面的书籍，告诉我们如何更加高效、准确地编程，是注重实效的工作方法论。书中没有过多的编程细节，更注重的是传授一般的工作方法，更准确来讲，是一种编程艺术和原则。在人们的编程过程中，随着工作时间和经历的项目增多，人逐渐从具体的东西中抽象出、总结归纳出一般的工作方法、编程原理原则。这是一个漫长的过程，可能要有数十年的工作才有更深的领悟。通过看这本书，我们可以预想得知，“这样的”、“那样的”的方法或许更好，从而避免了工作失误，同时，加快了工作效率。这是一本注重实效的书籍，一本实用性书籍。

编程是一个需要关注细节的过程，同时也是关注另外一些方法和东西，开会并不是完全没有意义，开会能够改变思考编程的方法，重新思考你的工作。作者把他在书中传授的工作方法叫做“模式语言”，并针对每种编程情况，给出较为具体的对策。通过阅读和思考这书中的内容，重新调整你的目前编程状态和方法。

软件的构造是工程学科，但它不排斥个人才艺。在每个项目中，充满了作者自身才艺的痕迹。提醒一句，高效的编程方法，是一个持续的过程，需要不断实践和总结，通过把新的技能加到新的项目去，不断进步。

## 注重实效的哲学
- 注重实效的程序员有什么特征？第一个特征是，他们对自己的工作负责，不害怕承认无知的错误，按时交付，并能够针对风险性供货、交付，制备一份应急计划。会提供各种选择，而不是找借口。这些特征，本质是为人做事的特征，不仅仅是在编程界，其他工作也亦一样。
- 软件的熵。没有维护的软件会腐败，最后被扔弃。作者根据，微小的破窗，会导致城市的犯罪率上升的“破窗理论”，认为软件中低劣设计，错误决策等软件部分，会导致整个工程迅速恶化。作者认为“洁癖”性代码，精益求精的设计，以及clean code方是上策。我认为，根据具体项目需求，“有计划”性的软件质量退化是必要的。我们拥有clean code，非凡的设计技巧，但并不是都需要用。
- 为什么要注意代码的整洁、有效、设计良好，并且优雅？一个原因是，不优雅的代码给其他同事、后人一种随便感觉，他们看到这些代码，会放松对自己写代码的要求，从而令协作关系产生的代码质量迅速下降，导致整个项目工程质量急剧恶化。
- 石头汤和煮青蛙故事，告诉我们，任何一个系统、产品、成果的产生，都首先是从微小的部分开始，任何经过演变、推进，慢慢复杂起来。软件开发也一样，开发产品原型，然后迅速迭代，一个个补丁打上去，最后让最初的一点痕迹都没有。温水煮青蛙故事，告诉我们，要留意变化，记得大图景，remember the big picture。学会判断变化与趋势，也是为人做事的一个本领。
- 任何开发，内心首先有一种准则，要编写足够好的软件。足够好的软件，包括满足用户需求，也包括代码本身质量足够好。
- 让你的用户参与权衡，什么是足够好的软件。有时为了追求软件质量，导致整个开发周期变长，用户耐心迅速下降，就得不偿失。知道何时止步，如果不懂何时止步，如同绘画，一层又一层把细节叠加，过度追求修饰和精益求精，那么所有的辛苦劳作就会白白浪费。
- 学会管理你的知识财产。IT行业更新非常快，同时也是一个高知识的行业，你应该像投资者一样，管理你的知识财产。主要方法包括，定期投资，学习新东西。多元化，你知道的事情越多，越有价值，作为广度，你应该知道目前特定技术的各种特性和局限性。管理风险，在技术投入上。重新评估和权衡，因为科技知识更新非常快，需要我们不断反思、评估现有的知识结构和认知系统。具体方法包括，定期学习一种新语言，定期阅读一本技术书籍，定期阅读非技术书籍，试验不同的生产环境，跟上潮流，构建自己的技术体系和认知思考框架与方法。交流和分享知识，更好地进步。让你的文档更加美观。做倾听者。即使回复他人。记住你说什么和你怎么说同样重要。
- 批判性思考，批判性地分析你读到的和听到的。尝试性挑战，如进行一门新的语言学习。多交流。让文档美观。

## 注重实效的途径 A Pragmatic Approach
- 维护的必要性。知识并不是稳定的，它是持续变化的，而且变化很快，需求、环境也是在变化，维护不是时有时无的东西，而是整个开发过程中例行的事务。
- 在开发过程中，一条准则是：不要重复你自己，don't repeat yourself。系统中的每一项知识都必须具有单一的、无歧义、权威的表示。
- 开发中常见的重复种类有：强加的重复，由于开发标准、设计语言、平台环境等这些因素，使得我们对信息的加工过程无法控制和选择，例如信息被迫多种表示，要求某些重复性的结构等。无意的重复，开发者没有意识到他们在重复信息。无耐性的重复，开发者偷懒，故意重复，这是有意识性在重复。开发者之间的重复，同一个项目中有不同的开发者，他们开发的功能可能在无意中被重复，这时解决的方法为多主动交流，让复用变得更加容易，Make it easy to resuse。
- 正交性系统。正交性的系统，意味着系统的功能分离和独立，消除无关事物之间的影响，所谓低耦合，高内聚的思想。编写正交性系统，要求我们设计具有self-contained的组件。正交带来的好处明显是，提高生产率、提高复用、降低风险、便于测试、降低团队成员间争吵的几率（因为功能明确，每个团队之间不会有交叉、重叠，他们之间不会直接接触，因此责任得到明确）。常常采用MVC模型来设计正交性的系统。
- 考虑代码与功能的可撤销性，以便制作灵活、有适应能力的软件，应对各类快速的需求，从来不存在最终的决策(There are no final decisions)。如果某种东西的自动添加的，那么它可以被自动去掉。
- 曳光代码。当客户什么都不明确，他自己想要什么都不知道，或者是我们在构建一个从没构建过的系统，这时候有两种方法：一是制作出大量的文档、逐一列举需求、确定所有未知因素、限定生产环境、进行大量的试验等等，这是一种精确性、大规模性的开发，但往往是浪费时间和精力。第二种方法是制作曳光代码，让曳光弹发现客户的目标，我们开发了一种原型系统，有了演示，让客户看到了能够工作的东西，让老板知道有了成果，让你有了一个集成平台、看得到工作进展，让测试人员有了测试环境。从此，快速迭代和更新，交互性设计更加强。曳光弹代码和原型代码不同的是，原型制作用过了的代码就扔弃，而曳光弹代码虽然简约，确是完整的，最终成为系统的骨架的一部分。原型制作可以看成是曳光弹代码前期进行的侦察和情报收集工作。例如在GUI演示时，我们用简单的语言做出一个东西出来，演示结束了，但到了具体开发，我们又换了一种贴合生产环境的代码，如汇编、c语言重新编写了这个GUI。这种情景叫原型开发。如果我们一开始就制作和现实世界相贴近的GUI，这就是曳光弹代码。55页
- 制作原型。制作原型的目的：为了学习而制作原型（prototype to learn)。原型制作并不是为了最终代码，而是在于学习到其经验。被制作原型的东西可以包括：架构、新功能、外部数据的结构或内容、第三方工具或组件、性能问题、用户界面设计GUI。根据制作原型的目的，我们在构建原型时，可以选择忽略掉包括正确性（在某些地方使用虚假数据）、完整性、健壮性、风格（甚至连注释代码也没有）。原型掩盖了细节，故可以采用非常高级的语言进行开发。在进行架构原型制作时，你可以一一思考以下但不局限于这些问题：
   - 主要组件的责任是否良好定义？是否恰当？
   - 组件之间的协作是否得到良好定义？
   - 耦合是否最小化？
   - 你是否确定重复的潜在来源？
   - 接口定义和各项约束是否可以接受？
   - 每个模块在执行过程中是否能访问到其所需的数据？是否能在需要的时进行访问？
- 是制作原型？还是制作曳光弹？如果制作的原型在演示时会给人误解，别人认为你的原型就是最终代码，那么你一是最好解释说原型不是最终，原型的代码不是最终代码，或最好还是制作曳光弹吧。这种正确判断和适应受困的所处的环境和文化，也是考验我们对项目工程的理解。
- 领域语言。计算机语言会影响我们的思考问题方式，每一种语言都有其适用的领域，我们总是以问题为导向，语言是工具，因此我们的原则是：Program close to the problem domain（靠近问题领域编程）。甚至，我们可以实现适用于该领域的最小语言。并思考，无论是自己实现某个语言，还是选择某个语言，是倾向易于开发，还是易于维护？
- 学会估算进度。估算，可以避免意外的发生（estimate to avoid surprises）。估算的单位会影响最终精度，如我们在规划一个项目周期，用天、周、月来作单位，得出的估算时间不一样。建议，这些单位都进行估算，最后综合，选择能反映出你想要传达的精度的单位。在规划和建模估算某个东西之前，你可以问下已经做过这件事的人，看看他们是如何解决这个问题，我们会得到很多经验，甚至早已存在最优/较好的解决方案。在建立估算之前，你想要理解问题所在，针对问题及其要素，建立系统模型，用模型思维（model thinking）去思考问题。把模型分解成组件，判断和描述组件之间是如何交互的，确定好组件参数，给每个参数指定值。估计模型/组件的时间复杂度和空间复杂度。在估算过程中，或是不可避免引入不准确性，或由于个人能力技巧经验原因，导致估算不准，这时不要放弃，要学会追踪你的估算能力，反思出现这种情况的原因，或是问题模型不对？或是模型参数问题？我们可以通过写估算日志，记录和追踪每次估算的精度程度。

## The basic tools
- 我们需要锻造自己的工具，随着工作经历的增加，我们会增加一些工具，我们要超越IDE，从纯文本开始，到IDE，再到工作台。作者提出纯文本对编码的促进作用，我认为使用vim工具是一个极好的选择。纯文本+shell是作者推崇的工具集。注重实效的程序员，更偏向使用命令行。作者提倡使用一种源码控制系统，always use source code control，我使用GitHub。在调试这块，作者认为调试是不可避免的，也是一种优秀的习惯，fix the problem, not the blame，要修正问题，而不是发出指责。数据的可视化有利于调试。作者认为DDD具有可视化能力，因而是一个很好的调试器。面对快速时代，我们与其花5个小时用生涩的语言验证一个想法，不如使用某种更加快捷的语言，花费30分钟试验一个疯狂的想法。
- 代码生成器。编写能够编写代码的代码。被动代码生成器：只运行一次来生成结果，然后结果就变成了独立的，它与代码生成器分离了。主动代码生成器：每次需要时，生成新的代码，而结果是由这些新代码产生。被动式代码生成器本质上是参数化模板，根据一组输入生成给定的输出形式。
